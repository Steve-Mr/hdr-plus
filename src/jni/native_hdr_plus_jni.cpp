#include <jni.h>
#include <vector>
#include <stdexcept>
#include <string>

#include "../Burst.h"
#include <align_and_merge.h> // Generated by Halide

extern "C" {

JNIEXPORT jbyteArray JNICALL Java_top_maary_darkbag_hdrplus_NativeHDRPlus_process(JNIEnv *env, jclass clazz, jobjectArray buffers) {
    try {
        if (buffers == nullptr) {
            throw std::invalid_argument("Buffers array is null");
        }

        int bufferCount = env->GetArrayLength(buffers);
        if (bufferCount == 0) {
            throw std::invalid_argument("Buffers array is empty");
        }

        std::vector<RawBuffer> rawBuffers;
        rawBuffers.reserve(bufferCount);

        for (int i = 0; i < bufferCount; i++) {
            jobject buffer = env->GetObjectArrayElement(buffers, i);
            if (buffer == nullptr) {
                throw std::invalid_argument("Buffer element is null");
            }

            void* address = env->GetDirectBufferAddress(buffer);
            jlong capacity = env->GetDirectBufferCapacity(buffer);

            if (address == nullptr) {
                throw std::invalid_argument("Buffer must be a direct ByteBuffer");
            }

            rawBuffers.push_back({address, static_cast<size_t>(capacity)});
        }

        // Create Burst from memory buffers
        Burst burst(rawBuffers);

        // Convert to Halide buffer (Input to pipeline)
        // Expected layout: (width, height, count)
        Halide::Runtime::Buffer<uint16_t> input = burst.ToBuffer();
        if (input.dimensions() != 3) {
             throw std::runtime_error("Failed to create input buffer from Burst");
        }

        // Prepare Output buffer
        // Expected layout: (width, height)
        // align_and_merge produces a single merged RAW image
        Halide::Runtime::Buffer<uint16_t> output(input.width(), input.height());

        // Run the pipeline
        int result = align_and_merge(input, output);
        if (result != 0) {
            throw std::runtime_error("align_and_merge pipeline failed with error code: " + std::to_string(result));
        }

        // Encode output to DNG in memory
        // We use the first frame as a template for metadata
        std::vector<uint8_t> dngData;
        burst.GetRaw(0).WriteDng(dngData, output);

        // Convert std::vector<uint8_t> to jbyteArray
        jbyteArray jResult = env->NewByteArray(dngData.size());
        if (jResult == nullptr) {
            throw std::runtime_error("Failed to allocate return byte array");
        }

        env->SetByteArrayRegion(jResult, 0, dngData.size(), reinterpret_cast<const jbyte*>(dngData.data()));

        return jResult;

    } catch (const std::exception& e) {
        jclass exceptionClass = env->FindClass("java/lang/RuntimeException");
        if (exceptionClass) {
            env->ThrowNew(exceptionClass, e.what());
        }
        return nullptr;
    } catch (...) {
        jclass exceptionClass = env->FindClass("java/lang/RuntimeException");
        if (exceptionClass) {
            env->ThrowNew(exceptionClass, "Unknown native exception occurred");
        }
        return nullptr;
    }
}

}
